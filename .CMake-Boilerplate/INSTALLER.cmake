#################################################################
#                                                               #
#              !!! CMAKE INSTALL AUTOMATION !!!                 #
#                                                               #
#   I want all of my projects to follow the same exact          #
#   style of versioning and "targetting" so I've created        #
#   this functional boilerplate. In essence, once we are        #
#   at install-time, we want to generate all of the meta-       #
#   data and stuff it in with the artifacts. This makes it      #
#   very very very easy to link projects together like legos,   #
#   it just takes some legwork initially to set the standard!   #
#                                                               #
#################################################################

###
### LOGICAL START IS AT THE BOTTOM OF THE FILE AT "DefaultInstall()"
###

# We need to configure and install some non-typical cmake files that should be passed around with out projects
# These allow projects to fit and link together much more fluidly.
function(GenerateMetaData PROJECT_NAME)

    # Lets do CMake's autogenerated install files thing with install(EXPORT)
    install(EXPORT ${PROJECT_NAME}-targets
            FILE "${PROJECT_NAME}-targets.cmake"
            DESTINATION share/cmake/${PROJECT_NAME}
        )
    
    # We use our project-config template in this directory to install a configured version into our package
    configure_file("${CMAKE_CURRENT_FUNCTION_LIST_DIR}/project-config.cmake"
        "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/cmake/${PROJECT_NAME}-config.cmake"
        @ONLY
    )

    # CMake has some package helper functions, so lets include them and use it to write a versioning file
    include(CMakePackageConfigHelpers)
    write_basic_package_version_file(
        "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/cmake/${PROJECT_NAME}-config-version.cmake"
        COMPATIBILITY AnyNewerVersion
    )

    # install the non-EXPORT fiels into this specific directory
    install(
        FILES
            "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/cmake/${PROJECT_NAME}-config.cmake"
            "${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/cmake/${PROJECT_NAME}-config-version.cmake"
        DESTINATION
            "share/cmake/${PROJECT_NAME}"
    )

endfunction(GenerateMetaData)

####      *     
####     *** 
####    *****
####   *******  Calls upwards!
####     ***
####     ***
####     ***

# Any install process initialization should go in here. To keep things clean, any multi repo-spanning variables should get changed here
function(InstallSetup PROJECT_NAME)   
    
    # I only use gnu because thats what I grew up with. We might need this later
    include(GNUInstallDirs)

    # The build script forces this variable, but if someone is command-lining, we might need to set it to avoid an error
    if(NOT CMAKE_BUILD_TYPE)
        set(CMAKE_BUILD_TYPE DEBUG)
    endif()
    
    # Now lets take care of the versioning and target cmake files!
    GenerateMetaData(${PROJECT_NAME})

endfunction(InstallSetup)

####      *     
####     *** 
####    *****
####   *******  Calls upwards!
####     ***
####     ***
####     ***

# A project will call this after configuring itself with all of its dependencies and building. So we can make an agnostic install function like so
function(DefaultInstall PROJECT_NAME)

    # But we de need to do some set up, and standardize some metadata
    InstallSetup(${PROJECT_NAME})
    
    # And once that setup is done, we can then just to a typical CMake install to create the package.
    install(TARGETS ${PROJECT_NAME} EXPORT ${PROJECT_NAME}-targets
        RUNTIME DESTINATION bin
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib
        INCLUDES DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
        PUBLIC_HEADER DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
    )

endfunction(DefaultInstall)